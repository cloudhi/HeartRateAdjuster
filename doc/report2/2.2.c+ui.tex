\begin{center}
 	\begin{tabular}{|l|C{3cm}|C{2.5cm}|C{2.5cm}|C{2.5cm}|C{2.5cm}|}
 		\hline
 			&  \multicolumn{4}{|c|}{\textit{Class}} \\  \hline
 
 			\textit{Domain Concepts}	&	\textbf{Data Manager}	&	\textbf{Data Assembler}	&	\textbf{Graph Container}	& \textbf{Ordered Pair} & \textbf{Heart Rate Monitor GUI} & \textbf{Heart Rate Monitor Hardware}	\\ \hline
 
 \textbf{HRM Manager}		&	X	&		&		&		&		&	X	\\ \hline
 \textbf{Log Retriever}		&	X	&		&		&		&		&		\\ \hline
 \textbf{Track Logger}		&	X	&		&		&		&		&		\\ \hline
 \textbf{Music Playerbacker}	&	X	&		&		&		&	X	&		\\ \hline
 \textbf{Track Queuer}		&	X	&	X	&		&		&		&		\\ \hline
 \textbf{General UI}			&	X	&	X	&		&		&	X	&		\\ \hline
 \textbf{Playback View}		&	X	&	X	&	X	&		&	X	&		\\ \hline
 \textbf{Heart Beat View}		&	X	&	X	&	X	&		&	X	&		\\ \hline
 \textbf{Workout View}		&	X	&	X	&	X	&		&	X	&		\\ \hline
 \textbf{History View}		&	X	&	X	&	X	&		&	X	&		\\ \hline
 \textbf{Workout Store}		&	X	&	X	&		&	X	&		&	\\ \hline
 \textbf{Metadata Store}		&	X	&	X	&		&	X	&		&	\\ \hline
 \textbf{Music Store}		&	X	&	X	&		&	X	&		&	\\ \hline
 
 	\end{tabular}
\end{center}
 
 	From our domain concepts, we derived four classes: data manager, data assembler, graph container, and ordered pair. Our data manager is essentially involved with every domain. Its purpose is to log and manage various types of data, and store the packaged data other objects to retrieve. Essentially, the data manger acts as an intermediary in most steps, but only providing a minimal interface for modules so that data cannot be tampered with or seen, just used.
 
 	Next, our data assembler is charged with retrieving the appropriate data from the database and packaging it in a convenient form for usage. For instance, we can take songs and metadata from their storage locations and return playlists. We can also take our data and create ordered pairs for our graph container. Then, our graph container contains an array of the requested graphs, and it is involved with the domain concepts that require various views. Using our data assembler allows us to have a nice container of data to graph. Finally, our ordered pair class was derived from the storage concepts. We use it to store data points, so that we will be able to access them.

	For the user interface and hardware communication, two other classes were derived rather clearly: the Graphical User Interface class, and the Hardware communication class. The graphical user interface is involved with many domains, save the few domains relating to data storage - that is taken care of by the data manager portion. The purpose of the graphical user interface is for users to be able to easily interact with the application. This includes being able to easily view different portions of the application such as information on their current workout, their history, etc. The next class, Hardware, was derived as a modularized way to communicate with the Heart Rate Monitor which is required to retrieve information about the user's heart rate. This class is simple - it's only function is to receive information from the HRM being used, and to update the user's current heart rate in real time.